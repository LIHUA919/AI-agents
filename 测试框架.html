
<!DOCTYPE html>
<html>
  <head>
    <title>Mocha Tests</title>
    <link rel="stylesheet" href="https://unpkg.com/mocha@5.2.0/mocha.css">
    <!-- <script src="../lodash/libs/infiniteLoopDetecter.js"></script> -->
  </head>
  <body>
    <div id="mocha"></div>
    <script src="https://unpkg.com/mocha@5.2.0/mocha.js"></script>
    <script src="https://unpkg.com/chai@4.1.2/chai.js"></script>
    <script>mocha.setup('bdd')</script>

    <!-- load code you want to test here -->

    <!-- load your test files here -->
    <script>
      var assert = chai.assert

      // function assert(test, str) {
      //   if (!test) {
      //     throw new Error(str)
      //   }
      // }

      // chai.should()

      describe('正则相关函数实现', () => {
        return
        it('RegExp.prototype.mytest', () => {
          assert(/foo/.mytest('foo') == true)
          assert(/foo/.mytest('bar') == false)
        })
        it('String.prototype.mysearch', () => {
          assert('foobarbaz'.mysearch('bar') == 3)
          assert('foobarbaz'.mysearch('bab') == -1)
        })
        it('String.prototype.mymatch', () => {
          var match = 'foobarfoobaz'.mymatch(/ba./)
          assert.deepEqual(match, ['bar'])
          assert(match.index == 3)
          assert.deepEqual('foobarfoobaz'.mymatch(/ba./g), ['bar', 'baz'])
        })

        it('String.prototype.myreplace function replacer', () => {
          assert('foobarbazfoobaa'.myreplace(/b/g, () => '#') == 'foo#ar#azfoo#aa')
          assert('foobarbazfoobaa'.myreplace(/b/, () => '#') == 'foo#arbazfoobaa')
          assert('foobarbazfoobaa'.myreplace(/ba(.)/g, (match, char) => {
            return char.toUpperCase()
          }) == 'fooRZfooA')
        })
        it('String.prototype.myreplace string replacer', () => {
          assert('foobarbazfoobaa'.myreplace(/b/g, '#') == 'foo#ar#azfoo#aa')
          assert('foobarbazfoobaa'.myreplace(/b/, '#') == 'foo#arbazfoobaa')
          assert('foobarbazfoobaa'.myreplace(/ba(.)/g, '$1$1$1') == 'foorrrzzzfooaaa')
        })
        it('String.prototype.mysplit', () => {
          assert.deepEqual('barfo1barfo2bar'.mysplit(/fo(\d)/), ['bar', '1', 'bar', '2', 'bar'])
        })
      })
      describe('PriorityQueue', () => {
        return
        it('是否实现', () => {
          assert(typeof PriorityQueue == 'function')
        })
        it('功能测试', () => {
          var pq = new PriorityQueue()
          pq.push(5)
          pq.push(1)
          pq.push(2)
          pq.push(8)
          assert(pq.peek() == 8, '堆顶应为8')
          assert(pq.pop() == 8, '应pop出堆顶元素')
          assert(pq.size == 3, '此时堆大小应该为3')
          pq.push(0)
          pq.push(11)
          pq.push(6)
          pq.push(9)
          assert(pq.peek() == 11, '堆顶应该为11')
          var ary = []
          while(pq.size) {
            ary.push( pq.pop() )
          }
          assert(ary.toString() == '11,9,6,5,2,1,0', 'pop出的顺序应从大到小')
        })
      })

      describe('是否用class实现的', () => {

        it('class Complex', () => {
          assert(typeof Complex === 'function', '未实现')
          assert(Complex.toString().startsWith('class'), '未用class实现')
        })
        it('class Vector', () => {
          assert(typeof Vector === 'function', '未实现')
          assert(Vector.toString().startsWith('class'), '未用class实现')
        })
        it('class Stack', () => {
          assert(typeof Stack === 'function', '未实现')
          assert(Stack.toString().startsWith('class'), '未用class实现')
        })
        it('class Queue', () => {
          assert(typeof Queue === 'function', '未实现')
          assert(Queue.toString().startsWith('class'), '未用class实现')
        })
        it('class LinkedList', () => {
          assert(typeof LinkedList === 'function', '未实现')
          assert(LinkedList.toString().startsWith('class'), '未用class实现')
        })
        it('class MyMap', () => {
          assert(typeof MyMap === 'function', '未实现')
          assert(MyMap.toString().startsWith('class'), '未用class实现')
        })
        it('class MySet', () => {
          assert(typeof MySet === 'function', '未实现')
          assert(MySet.toString().startsWith('class'), '未用class实现')
        })
      })

      describe('是否实现了', () => {
        it('Vector', () => {
          assert(typeof Vector === 'function', '未实现')
        })
        it('Complex', () => {
          assert(typeof Complex === 'function', '未实现')
        })
        it('Stack', () => {
          assert(typeof Stack === 'function', '未实现')
        })
        it('Queue', () => {
          assert(typeof Queue === 'function', '未实现')
        })
        it('LinkedList', () => {
          assert(typeof LinkedList === 'function', '未实现')
        })
        it('MyMap', () => {
          assert(typeof MyMap === 'function', '未实现')
        })
        it('MySet', () => {
          assert(typeof MySet === 'function', '未实现')
        })
      })

      describe('Vector', () => {
        describe('+', () => {
          it('+++', () => {})
        })
        describe('-', () => {
          it('---', () => {})
        })
        it('加减运算', () => {
          var a = new Vector(1,2)
          var b = new Vector(2,2)
          var c = a.plus(b)
          var d = a.minus(b)
          assert(c.x == 3, 'a+b的x应该为3')
          assert(c.y == 4, 'a+b的y应该为4')
          assert(d.x == -1, 'a-b的x应为-1')
          assert(d.y == 0, 'a-b的y应为0')
          assert(c.length == 5,'a+b的长度应为5')
        })
      })
      describe('Complex', () => {
        it('除法', () => {
          var a = new Complex(1,2)
          var b = new Complex(2,4)
          var c = a.div(b)
          
          assert(c.real == 0.5, 'a/b的实部应该为0.5')

          assert(c.imag == 0, 'a/b的虚部应该为0')
        })
      })




      describe('Stack', () => {
        it('基本测试', () => {
          var s = new Stack()
          s.push(1)
          s.push(2)
          s.push(3)
          assert(s.pop() == 3, 'pop出来的应该是3')
          s.push(4)
          assert(s.pop() == 4, 'pop出来的应该是4')
          assert(s.size == 2, 'size应该为2')
        })
      })

      describe('Queue', () => {
        it('基本测试', () => {
          var s = new Queue()
          s.add(1)
          s.add(2)
          s.add(3)
          assert(s.pop() == 1, '出队的应该为1')
          assert(s.pop() == 2, '出队的应该为2')
          assert(s.size == 1, '队列长度应该为1')
        })
      })

      describe('LinkedList', () => {
        it('基本测试', () => {
          var s = new LinkedList()
          s.append(1)
          s.append(2)
          s.prepend(3)
          assert(s.size == 3, '链表长度应该为3')
          s.prepend(4)
          assert(s.at(0) == 4, '0号位置应该为4')
          assert(s.at(1) == 3, '1号位应该为3')
          assert(s.at(3) == 2, '3号位应该为2')
        })
      })

      describe('测试MyMap', () => {
        it('基础测试', () => {
          var a = new MyMap()
          a.set('foo', 1)
          a.set('bar', 2)
          assert(a.get('foo') == 1)
          a.set('foo', 3)
          assert(a.get('foo') == 3)
          assert(a.size == 2)
          a.delete("foo")
          assert(a.size == 1)
        })
      })

      describe('测试MySet', () => {
        it('基础测试', () => {
          var s = new MySet()
          s.add("foo")
          s.add("foo")
          s.add("bar")
          assert(s.size == 2, '不能有重复元素')
          s.delete('foo')
          assert(s.size == 1)
          assert(s.has('foo') == false)
        })
      })
    </script>

    <script>
      async function main() {
        var taskUrl = location.hash.substr(1)
        var script = document.createElement('script')
        script.src = taskUrl
        document.body.append(script)
        script.onload = () => {
          mocha.run()
        }
        // var taskCode = await fetch(taskUrl).then(it => it.text())
        // eval(infiniteLoopDetector.wrap(taskCode))
        // mocha.run();
      }
      main()
    </script>
  </body>
</html>

作业：

function describe(description, func) {

}
<!-- 实现以上函数，已让下面的调用能够输出最后的效果 -->
describe('foo', () => {
  describe('bar', () => {})
  describe('bar', () => {
    describe('bar1', () => {})
    describe('bar1', () => {})
    describe('bar1', () => {})
  })
  describe('bar', () => {})
})

foo
  bar
  bar
    bar1
    bar1
    bar1
  bar
